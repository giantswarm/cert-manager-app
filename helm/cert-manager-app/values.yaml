# Default values for the cert-manager-app.
# You can set some of these values by supplying your own values when creating
# your app. See https://docs.giantswarm.io/reference/app-configuration/

# -----------------------------------------------------------------------------#

# DO NOT copy this entire file and use it as your values file. This will impede
# upgrading and our own ability to correct issues with the base configuration.

# -----------------------------------------------------------------------------#

# cainjector
cainjector:

  # cainjector.extraArgs
  # Pass extra arguments to the cainjector container. These should be passed as
  # an array e.g. `- --add_dir_header`.
  extraArgs: []

  # cainjector.image
  image:

    # cainjector.image.pullPolicy
    pullPolicy: IfNotPresent

  # cainjector.logLevel
  # Set the log level (defaults to 2 if not specified).
  logLevel: null

  # cainjector.replicas
  # How many replicas of the cainjector to run. Cainjectors hold elections and only one
  # is active at one time.
  replicas: 1

  # cainjector.resources
  resources:

    # cainjector.resources.requests
    # Minimum resources requested for the Deployment.
    requests:
      cpu: 10m
      memory: 32Mi

  serviceAccount:
    automountServiceAccountToken: true

# controller
controller:

  # AWS parameters to configure cert manager to work with AWS Route53
  aws:

    # Role name used to authenticate cert manager against AWS API
    role: ""

  # controller.defaultIssuer
  # Sets the default certificate issuer; this behaviour can be disabled by setting
  # controller.defaultIssuer to an empty dictionary e.g. `controller.defaultIssuer: {}`.
  # Note that disabling the default issuer means that each Certificate request must
  # have an explicit issuerRef set.
  defaultIssuer:

    # controller.defaultIssuer.group
    # API group of the Issuer to use when a Certificate is requested but no issuerRef
    # is provided.
    group: cert-manager.io

    # controller.defaultIssuer.kind
    # Kind of the Issuer to use when a Certificate is requested but no issuerRef is provided.
    kind: ClusterIssuer

    # controller.defaultIssuer.name
    # Name of the Issuer to use when a Certificate is requested but no issuerRef is provided.
    # If this is set to the default value of `letsencrypt-giantswarm`, then
    # `global.giantSwarmClusterIssuer.install` must also be enabled.
    name: letsencrypt-giantswarm

  # controller.extraArgs
  # Pass extra arguments to the controller container. These should be passed as
  # an array e.g. `- --add_dir_header`.
  extraArgs: []

  # controller.image
  image:

    # controller.image.pullPolicy
    pullPolicy: IfNotPresent

  # controller.logLevel
  # Controller log level (defaults to 2 if not specified).
  logLevel: null

  # controller.replicas
  # How many replicas of the controller to run. Controllers hold elections and only one
  # is active at one time.
  replicas: 1

  # controller.resources
  resources:

    # controller.resources.requests
    # Minimum resources requested for the Deployment.
    requests:
      cpu: 50m
      memory: 100Mi

  serviceAccount:
    automountServiceAccountToken: true

# crds
#
crds:

  # crds.backoffLimit
  # setting this higher means the CRD creation is less likely to be marked
  # as failed.
  backoffLimit: 10

  # crds.image
  image:

    # crds.image.pullPolicy
    pullPolicy: IfNotPresent

  # crds.install
  # CRDs are installed by default. If this is disabled then CRDs must
  # be managed by another method.
  install: true

  # crds.resources
  resources:

    # crds.resources.requests
    # Minimum resources requested for the Job.
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi

# global
# Global vars are also available to subcharts.
global:

  # global.acmeSolver
  acmeSolver:
    # global.acmeSolver.DNSServer
    # IP address of the authorative DNS server to query for challenge records. If the
    # installation is behind a proxy then this should be the cluster CoreDNS IP.
    DNSServer: ""

    # global.acmeSolver.secret
    secret:
      # global.acmeSolver.secret.cloudflare
      cloudflare:
        # global.acmeSolver.secret.cloudflare.token
        # Cloudflare API token with sufficient scope to create/delete records.
        token: ""

    # global.acmeSolver.type
    # ACME solver challenge type (see https://letsencrypt.org/docs/challenge-types/).
    type: http01

  # global.enableCertOwnerRef
  # when this flag is enabled, secrets will be automatically removed when the parent
  # certificate resource is deleted.
  enableCertOwnerRef: false

  # global.giantSwarmClusterIssuer
  giantSwarmClusterIssuer:
    # global.giantSwarmClusterIssuer.install
    # Setting this option to true enables the `giantswarm-cluster-issuer` sub-chart which
    # creates a ClusterIssuer for LetsEncrypt. If this is disabled then new values must
    # be provided to via the controller.defaultIssuer values. Alternatively, the default
    # issuer can be disabled entirely.
    install: true

  # global.image
  image:

    # global.image.registry
    # Source registry of all images used in this chart.
    # IMPORTANT: this should not be changed.
    registry: docker.io

    # global.image.version
    # cert-manager version.
    # IMPORTANT: this should not be changed.
    # NOTE: When upgrading, make sure to reflect the change in Chart.yaml metadata too.
    version: v1.5.3

  # global.name
  # Set the name stub used in all resources. If not set, the Helm release
  # name will be used.
  name: cert-manager

  # global.securityContext
  # Pods must run as an unprivileged user in Giant Swarm clusters.
  securityContext:

    # global.securityContext.groupID
    groupID: 1000

    # global.securityContext.userID
    userID: 1000

    # global.securityContext.runAsNonRoot
    runAsNonRoot: true

# prometheus
prometheus:

  # prometheus.enabled
  # Enables monitoring by setting standard Prometheus annotations used in
  # service discovery.
  enabled: true

# webhook
webhook:

  # web.extraArgs
  # Pass extra arguments to the webhook container. These should be passed as
  # an array e.g. `- --add_dir_header`.
  extraArgs: []

  # webhook.image
  image:

    # webhook.image.pullPolicy
    pullPolicy: IfNotPresent

  # webhook.logLevel
  # Set the log level (defaults to 2 if not specified)
  logLevel: null

  # webhook.mutatingWebhookConfigurationAnnotations
  # Optional additional annotations to add to the webhook MutatingWebhookConfiguration
  mutatingWebhookConfigurationAnnotations: {}

  # webhook.replicas
  # How many replicas of the webhook to run.
  replicas: 1

  # webhook.resources
  resources:

    # webhook.resources.requests
    # Minimum resources requested for the Deployment.
    requests:
      cpu: 20m
      memory: 50Mi

  # webhook.securePort
  # Port to listen on for TLS conections.
  securePort: 10250

  # webhook.timeoutSeconds
  # Timeout for mutating and validating webhooks.
  timeoutSeconds: 10

  # webhook.validatingWebhookConfigurationAnnotations
  # Optional additional annotations to add to the webhook ValidatingWebhookConfiguration
  validatingWebhookConfigurationAnnotations: {}

  serviceAccount:
    automountServiceAccountToken: true

# This startupapicheck is a Helm post-install hook that waits for the webhook
# endpoints to become available.
startupapicheck:
  enabled: true

  # Pod Security Context to be set on the startupapicheck component Pod
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  securityContext:
    runAsNonRoot: true

  # Timeout for 'kubectl check api' command
  timeout: 1m

  # Job backoffLimit
  backoffLimit: 4

  # Optional additional annotations to add to the startupapicheck Job
  jobAnnotations:
    helm.sh/hook: post-install
    helm.sh/hook-weight: "1"
    helm.sh/hook-delete-policy: hook-succeeded

  # Optional additional annotations to add to the startupapicheck Pods
  # podAnnotations: {}

  # Optional additional arguments for startupapicheck
  extraArgs: []

  resources:
    requests:
      cpu: 10m
      memory: 32Mi

  nodeSelector: {}

  affinity: {}

  tolerations: []

  # Optional additional labels to add to the startupapicheck Pods
  podLabels: {}

  image:
    repository: giantswarm/cert-manager-ctl

    # Override the image tag to deploy by setting this variable.
    # If no value is set, global.image.version will be used.
    # tag: canary

    # Setting a digest will override any tag
    # digest: sha256:0e072dddd1f7f8fc8909a2ca6f65e76c5f0d2fcfb8be47935ae3457e8bbceb20

    pullPolicy: IfNotPresent

  rbac:
    annotations:
      helm.sh/hook: post-install
      helm.sh/hook-weight: "-5"
      helm.sh/hook-delete-policy: hook-succeeded

  serviceAccount:
    # Specifies whether a service account should be created
    create: true

    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    # name: ""

    # Optional additional annotations to add to the Job's ServiceAccount
    annotations:
      helm.sh/hook: post-install
      helm.sh/hook-weight: "-5"
      helm.sh/hook-delete-policy: hook-succeeded

    # Automount API credentials for a Service Account.
    automountServiceAccountToken: true
