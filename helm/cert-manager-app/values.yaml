# Default values for the cert-manager-app.
# You can set some of these values by supplying your own values when creating
# your app. See https://docs.giantswarm.io/reference/app-configuration/

# -----------------------------------------------------------------------------#

# DO NOT copy this entire file and use it as your values file. This will impede
# upgrading and our own ability to correct issues with the base configuration.

# -----------------------------------------------------------------------------#

# cainjector
cainjector:
  # cainjector.extraArgs
  # Pass extra arguments to the cainjector container. These should be passed as
  # an array e.g. `- --add_dir_header`.
  extraArgs: []

  # cainjector.image
  image:
    # cainjector.image.pullPolicy
    pullPolicy: IfNotPresent

  # cainjector.logLevel
  # Set the log level (defaults to 2 if not specified).
  logLevel: null

  # cainjector.replicas
  # How many replicas of the cainjector to run. Cainjectors hold elections and only one
  # is active at one time.
  replicas: 1

  podAnnotations:
    # When using single replica we need to annotate the pod for Cluster Autoscaler to allow eviction in kube-system namespace
    cluster-autoscaler.kubernetes.io/safe-to-evict: "true"

  # cainjector.resources
  resources:
    # cainjector.resources.requests
    # Minimum resources requested for the Deployment.
    requests:
      cpu: 10m
      memory: 32Mi

  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true
    runAsNonRoot: true

  serviceAccount:
    # Optional additional labels to add to the cainjector's ServiceAccount
    # labels: {}
    automountServiceAccountToken: true

# controller
controller:
  # AWS parameters to configure cert manager to work with AWS Route53
  aws:
    # Role name used to authenticate cert manager against AWS API
    role: ""
    irsa: "false"

  # controller.defaultIssuer
  # Sets the default certificate issuer; this behaviour can be disabled by setting
  # controller.defaultIssuer to an empty dictionary e.g. `controller.defaultIssuer: {}`.
  # Note that disabling the default issuer means that each Certificate request must
  # have an explicit issuerRef set.
  defaultIssuer:
    # controller.defaultIssuer.group
    # API group of the Issuer to use when a Certificate is requested but no issuerRef
    # is provided.
    group: cert-manager.io

    # controller.defaultIssuer.kind
    # Kind of the Issuer to use when a Certificate is requested but no issuerRef is provided.
    kind: ClusterIssuer

    # controller.defaultIssuer.name
    # Name of the Issuer to use when a Certificate is requested but no issuerRef is provided.
    # If this is set to the default value of `letsencrypt-giantswarm`, then
    # `global.giantSwarmClusterIssuer.install` must also be enabled.
    name: letsencrypt-giantswarm

  # controller.extraArgs
  # Pass extra arguments to the controller container. These should be passed as
  # an array e.g. `- --add_dir_header`.
  extraArgs: []

  # controller.image
  image:
    # controller.image.pullPolicy
    pullPolicy: IfNotPresent

  # controller.logLevel
  # Controller log level (defaults to 2 if not specified).
  logLevel: null

  # controller.replicas
  # How many replicas of the controller to run. Controllers hold elections and only one
  # is active at one time.
  replicas: 1

  podAnnotations:
    # When using single replica we need to annotate the pod for Cluster Autoscaler to allow eviction in kube-system namespace
    cluster-autoscaler.kubernetes.io/safe-to-evict: "true"

  # controller.resources
  resources:
    # controller.resources.requests
    # Minimum resources requested for the Deployment.
    requests:
      cpu: 50m
      memory: 100Mi

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    # name: ""
    # Optional additional annotations to add to the controller's ServiceAccount
    # annotations: {}
    # Automount API credentials for a Service Account.
    # Optional additional labels to add to the controller's ServiceAccount
    # labels: {}
    automountServiceAccountToken: true
    annotations: {}

# crds
#
crds:
  # crds.backoffLimit
  # setting this higher means the CRD creation is less likely to be marked
  # as failed.
  backoffLimit: 10

  # crds.image
  image:
    # crds.image.pullPolicy
    pullPolicy: IfNotPresent

  # crds.install
  # CRDs are installed by default. If this is disabled then CRDs must
  # be managed by another method.
  install: true

  # crds.resources
  resources:
    # crds.resources.requests
    # Minimum resources requested for the Job.
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi

# set the HTTP_PROXY, HTTPS_PROXY and NO_PROXY variable
proxy:
  noProxy:
  http:
  https:


# provider
# Identifies the cloud provider. Currently supported: `aws` and `azure`. This *must*
# be set. If this is installed as a default app from the default-catalog then this
# value is set dynamically and will be overridden.
provider: CHANGEME

# clusterID
# The cluster's ID. This is only used if this chart is installed as a default app
# from the default-catalog. It is dynamically set and will be overridden. Specific
# to Giant Swarm clusters.
clusterID: ""

cluster:
  # is getting overwritten by the top level proxy if set
  # These values are generated via cluster-apps-operator
  proxy:
    noProxy:
    http:
    https:

# global
# Global vars are also available to subcharts.
global:
  # global.acmeSolver
  acmeSolver:
    # global.acmeSolver.DNSServer
    # IP address of the authorative DNS server to query for challenge records. If the
    # installation is behind a proxy then this should be the cluster CoreDNS IP.
    DNSServer: ""

    # global.acmeSolver.provider
    # DNS provider used to create DNS01 challenge records.
    # Supported providers:
    #   - cloudflare
    #   - route53
    provider: ""

    # global.acmeSolver.secret
    secret:
      # global.acmeSolver.secret.cloudflare
      cloudflare:
        # global.acmeSolver.secret.cloudflare.token
        # Cloudflare API token with sufficient scope to create/delete records.
        token: ""

      # global.acmeSolver.secret.route53
      route53:
        # global.acmeSolver.secret.route53.accessKeyID
        # route53 user access key.
        accessKeyID: ""
        # global.acmeSolver.secret.route53.region
        # route53 region.
        region: ""
        # global.acmeSolver.secret.route53.secretAccessKey
        # route53 role to assume.
        role: ""
        # global.acmeSolver.secret.route53.secretAccessKey
        # route53 user secret access key.
        secretAccessKey: ""

    # global.acmeSolver.type
    # ACME solver challenge type (see https://letsencrypt.org/docs/challenge-types/).
    type: http01

  # global.enableCertOwnerRef
  # when this flag is enabled, secrets will be automatically removed when the parent
  # certificate resource is deleted.
  enableCertOwnerRef: false

  # global.giantSwarmClusterIssuer
  giantSwarmClusterIssuer:
    # global.giantSwarmClusterIssuer.install
    # Setting this option to true enables the `giantswarm-cluster-issuer` sub-chart which
    # creates a ClusterIssuer for LetsEncrypt. If this is disabled then new values must
    # be provided to via the controller.defaultIssuer values. Alternatively, the default
    # issuer can be disabled entirely.
    install: true

  # global.image
  image:
    # global.image.registry
    # Source registry of all images used in this chart.
    # IMPORTANT: this should not be changed.
    registry: docker.io

    # global.image.version
    # cert-manager version.
    # IMPORTANT: this should not be changed.
    # NOTE: When upgrading, make sure to reflect the change in Chart.yaml metadata too.
    version: v1.12.4

  # global.name
  # Set the name stub used in all resources. If not set, the Helm release
  # name will be used.
  name: cert-manager

  # global.securityContext
  # Pods must run as an unprivileged user in Giant Swarm clusters.
  securityContext:
    # global.securityContext.groupID
    groupID: 1000

    # global.securityContext.userID
    userID: 1000

    # global.securityContext.runAsNonRoot
    runAsNonRoot: true

    seccompProfile:
      type: RuntimeDefault

  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL

  rbac:
    # Aggregate ClusterRoles to Kubernetes default user-facing roles. Ref: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
    aggregateClusterRoles: true

  podSecurityStandards:
    enforced: false

  podSecurityPolicy:
    enabled: true
    useAppArmor: false
# prometheus
prometheus:
  # prometheus.enabled
  # Enables monitoring by setting standard Prometheus annotations used in
  # service discovery.
  enabled: true

# webhook
webhook:
  # web.extraArgs
  # Pass extra arguments to the webhook container. These should be passed as
  # an array e.g. `- --add_dir_header`.
  extraArgs: []

  # webhook.image
  image:
    # webhook.image.pullPolicy
    pullPolicy: IfNotPresent

  # webhook.logLevel
  # Set the log level (defaults to 2 if not specified)
  logLevel: null

  # webhook.mutatingWebhookConfigurationAnnotations
  # Optional additional annotations to add to the webhook MutatingWebhookConfiguration
  mutatingWebhookConfigurationAnnotations: {}

  # webhook.replicas
  # How many replicas of the webhook to run.
  replicas: 2

  # webhook.resources
  resources:
    # webhook.resources.requests
    # Minimum resources requested for the Deployment.
    requests:
      cpu: 20m
      memory: 50Mi

  # Used to configure options for the webhook pod.
  # This allows setting options that'd usually be provided via flags.
  # An APIVersion and Kind must be specified in your values.yaml file.
  # Flags will override options that are set here.
  config:
    # apiVersion: webhook.config.cert-manager.io/v1alpha1
    # kind: WebhookConfiguration

    # The port that the webhook should listen on for requests.
    # In GKE private clusters, by default kubernetes apiservers are allowed to
    # talk to the cluster nodes only on 443 and 10250. so configuring
    # securePort: 10250, will work out of the box without needing to add firewall
    # rules or requiring NET_BIND_SERVICE capabilities to bind port numbers <1000.
    # This should be uncommented and set as a default by the chart once we graduate
    # the apiVersion of WebhookConfiguration past v1alpha1.
    # securePort: 10250

  # webhook.podDisruptionBudget
  podDisruptionBudget:
    # webhook.podDisruptionBudget.enabled
    # Whether to enable the PodDisruptionBudget or not.
    enabled: true
    # webhook.podDisruptionBudget.minAvailable
    # Minimum number of available pods during intended node maintenances.
    minAvailable: 1
    # webhook.podDisruptionBudget.maxUnavailable
    # Maximum number of unavailable pods during intended node maintenances.
    # maxUnavailable: 1

  # webhook.securePort
  # Port to listen on for TLS conections.
  # If webhook.config is specified, this values is unused.
  securePort: 10250

  # webhook.timeoutSeconds
  # Timeout for mutating and validating webhooks.
  timeoutSeconds: 10

  # webhook.validatingWebhookConfigurationAnnotations
  # Optional additional annotations to add to the webhook ValidatingWebhookConfiguration
  validatingWebhookConfigurationAnnotations: {}

  serviceAccount:
    # Optional additional labels to add to the webhook's ServiceAccount
    # labels: {}
    automountServiceAccountToken: true

  # webhook.url
  # Overrides the mutating webhook and validating webhook so they reach the webhook
  # service using the `url` field instead of a service.
  url:
    {}
    # host:

  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true
    runAsNonRoot: true

# This startupapicheck is a Helm post-install hook that waits for the webhook
# endpoints to become available.
startupapicheck:
  enabled: true

  # Pod Security Context to be set on the startupapicheck component Pod
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  # Container Security Context to be set on the controller component container
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true

  # Timeout for 'kubectl check api' command
  timeout: 40s

  # Job backoffLimit
  backoffLimit: 10

  # Optional additional annotations to add to the startupapicheck Job
  jobAnnotations:
    helm.sh/hook: post-install
    helm.sh/hook-weight: "1"
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

  # Optional additional annotations to add to the startupapicheck Pods
  # podAnnotations: {}

  # Optional additional arguments for startupapicheck
  extraArgs: []

  resources:
    requests:
      cpu: 10m
      memory: 32Mi

  nodeSelector: {}

  affinity: {}

  tolerations: []

  # Optional additional labels to add to the startupapicheck Pods
  podLabels: {}

  image:
    repository: giantswarm/cert-manager-ctl

    # Override the image tag to deploy by setting this variable.
    # If no value is set, global.image.version will be used.
    # tag: canary

    # Setting a digest will override any tag
    # digest: sha256:0e072dddd1f7f8fc8909a2ca6f65e76c5f0d2fcfb8be47935ae3457e8bbceb20

    pullPolicy: IfNotPresent

  rbac:
    # annotations for the startup API Check job RBAC and PSP resources
    annotations:
      helm.sh/hook: post-install
      helm.sh/hook-weight: "-5"
      helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

  serviceAccount:
    # Specifies whether a service account should be created
    create: true

    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    # name: ""

    # Optional additional labels to add to the startupapicheck's ServiceAccount
    # labels: {}

    # Optional additional annotations to add to the Job's ServiceAccount
    annotations:
      helm.sh/hook: post-install
      helm.sh/hook-weight: "-5"
      helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

    # Automount API credentials for a Service Account.
    automountServiceAccountToken: true

ciliumNetworkPolicy:
  enabled: false
